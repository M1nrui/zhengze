正则，一种规则，把人能读懂的语音转换成计算机能读懂的语音。
用来匹配字符串

写法
1 简写： /规则/ 性能高
2 new Regexp(字符串的规则，修饰符)
例 new Regexp('a') = /a/;

正则的开始与结束
 ^  $

转译符： 一个\加一个普通的字符，代表一段特殊的字符；
转译符在‘’中时，\也需要转译，例‘\\n’
\n 换行
\N 非换行
\r 回车
\R 非回车
\d 数字
\D 非数字

修饰符： 
g ―― global 全局
i 忽略大小写
写在正则外，修饰符不分前后

量词
+ 最少一个，最多无数个
？最少一个都没有，最大一个
	
正则的特性：
懒惰：
匹配到某个规则之后，那么直接返回。
				
贪婪:
会一直找量词中匹配的字符，有多少就匹配多少。			

正则的方法
test
查看正则表达式与指定字符串是否匹配（匹配类似与包含与被包含的关系）如果匹配，返回一个布尔值（true），否则（false）
re.test(str)；

match
将匹配的字符串放到一个数组中，匹配成功一个，就成为数组中的一位。
字符串方法
str.match （正则）

search 找到字符串中指定字符的位置，有就返回位置，没有就返回-1

字符串方法
str.search(''||re)  里面可以是字符，也可以是正则
str.search(/x/)

replace()
字符串方法
将字符串指定的字符（正则）替换成另一个
str.replace(                       ,                     )
            要替换的内容或者正则    替换成的内容，也可以是一个回调函数的返回值
回调函数的形参，通常写成$0,$1,$2....
$0 为正则每次匹配的字符
$1 正则匹配的字符在字符串里的位置
$2 整个字符串 all
$3 underfined
当正则有子项时，从replace回调的第二个形参开始，一一对应匹配的子项

重复子项
e\1   ee
e\1+ eeeee
1对应的是自己是第几个子项
但值得注意的是你找e的时候，找到的是一个

[]里面写任意的字符
例 [abc] = a|b|c

量词
+ 最少一个，最多wuqio
？最少没有，最多一个
*最少没有，最多无穷
{n,m}最少n个，最多m个
{n,}最少n个，最多无穷
{0,}最少0个，最多无穷
